#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

//global variables
double **firstMatrix;
double **secondMatrix;
double **seqMatrix;
double **parMatrix;
double **partialMatrix;

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 * 
 * @param matrixSize the size of the matrix to initialize
 */
void mmm_init(int matrixSize)
{
	// TODO
	// allocate memory for rows for all matrices
	firstMatrix = (double **)malloc(matrixSize * sizeof(double *));
	secondMatrix = (double **)malloc(matrixSize * sizeof(double *));
	seqMatrix = (double **)malloc(matrixSize * sizeof(double *));
	parMatrix = (double **)malloc(matrixSize * sizeof(double *));
	// allocate memory for the columns of the matrices
	for(int i = 0; i < matrixSize; i++) {
		firstMatrix[i] = (double *)malloc(matrixSize * sizeof(double));
		secondMatrix[i] = (double *)malloc(matrixSize * sizeof(double));
		seqMatrix[i] = (double *)malloc(matrixSize * sizeof(double));
		parMatrix[i] = (double *)malloc(matrixSize * sizeof(double));
	}
	// init the first and second matrix to have random ints
	for(int i = 0; i < matrixSize; i++) {
		for(int j = 0; j < matrixSize; j++) {
			firstMatrix[i][j] = rand() % 100;
			secondMatrix[i][j] = rand() % 100;
		}
	}
	// make the seq and par matrix hold 0's
	mmm_reset(seqMatrix, matrixSize);
	mmm_reset(parMatrix, matrixSize);
}

/**
 * Reset a given matrix to zeroes
 */
void mmm_reset(double **matrix, int matrixSize)
{
	// TODO
	for(int i = 0; i < matrixSize; i++) {
		for(int j = 0; j < matrixSize; j++) {
			//make every spot in the matrix 0
			matrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	// TODO
	free(firstMatrix);
	free(secondMatrix);
	free(seqMatrix);
	free(parMatrix);
}

/**
 * Sequential MMM
 */
void mmm_seq(int matrixSize)
{
	// TODO - code to perform sequential MMM
	for(int i = 0; i < matrixSize; i++) {
		for(int j = 0; j < matrixSize; j++) {
			double matrixIndex = 0;
			for(int k = 0; k < matrixSize; k++) {
				// a[i][k] * b[k][j] for matrix multiplication
				matrixIndex += firstMatrix[i][k] * secondMatrix[k][j];
			}
			//place the sigma above into seqMatrix[i][j]
			seqMatrix[i][j] = matrixIndex;
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{
	// TODO - code to perform parallel MMM
	thread_args *parArgs = (thread_args *) args;
	// split by rows
	for(int i = parArgs->beginRow; i <= parArgs->finishRow; i++) {
		for(int j = 0; j < parArgs->matrixSize; j++) {
			double matrixIndex = 0;
			for(int k = 0; k < parArgs->matrixSize; k++) {
				// a[i][k] * b[k][j] for matrix multiplication
				matrixIndex += firstMatrix[i][k] * secondMatrix[k][j];
			}
			//place the sigma above into seqMatrix[i][j]
			parMatrix[i][j] = matrixIndex;
		}
	}
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 */
double mmm_verify(int matrixSize)
{
	// TODO
	double verified = 0;
	for(int i = 0; i < matrixSize; i++) {
		for(int j = 0; j < matrixSize; j++) {
			verified += (seqMatrix[i][j] - parMatrix[i][j]);
		}
	}
	return verified;
}
